module sequences;

members {
    Sequence,
    nil,
    isNil,
    cons,
    head,
    any,
    all,
    lazyCons,
    forEach,
    singleton,
    reversed
}

import _sequences;
import options;
import trampolining;

val Sequence = _sequences.Sequence;
val nil = _sequences.nil;
val isNil = _sequences.isNil;
val cons = _sequences.cons;

def head fun[T] => (sequence: Sequence[T]) => 
    if isNil(sequence) then
        options.none
    else
        options.some[T](sequence.head());

def any fun[T] => (predicate: Function[T, Boolean], sequence: Sequence[T]) =>
    trampolining.trampoline(fun() => anyTrampolined[T](predicate, sequence));
    
def anyTrampolined fun[T] => (predicate: Function[T, Boolean], sequence: Sequence[T]) =>
    if isNil(sequence) then
        trampolining.stop(false)
    else if predicate(sequence.head()) then
        trampolining.stop(true)
    else
        trampolining.nextFunction(fun() => anyTrampolined[T](predicate, sequence.tail()));

def all fun[T] => (predicate: Function[T, Boolean], sequence: Sequence[T]) =>
    trampolining.trampoline(fun() => allTrampolined[T](predicate, sequence));
    
def allTrampolined fun[T] => (predicate: Function[T, Boolean], sequence: Sequence[T]) =>
    if isNil(sequence) then
        trampolining.stop(true)
    else if predicate(sequence.head()) then
        trampolining.nextFunction(fun() => allTrampolined[T](predicate, sequence.tail()))
    else
        trampolining.stop(false);

def lazyCons fun[T] => (myHead: T, deferredTail: Function[Sequence[T]]) =>
    object {
        public def head fun() => myHead;
        public val tail = deferredTail;
    };

def forEach fun[T] => (func: Function[T, Unit], sequence: Sequence[T]) =>
    trampolining.trampoline(fun() => forEachTrampolined[T](func, sequence));
    
def forEachTrampolined fun[T] => (func: Function[T, Unit], sequence: Sequence[T]) =>
    if isNil(sequence) then do {
        return trampolining.stop(());
    } else do {
        func(sequence.head());
        return trampolining.nextFunction(fun() => forEachTrampolined[T](func, sequence.tail()));
    };

def singleton fun[T] => (value: T) => object {
    public def head fun() => value;
    public def tail fun() => nil;
};

def reversed fun[T] => (sequence: Sequence[T]) : Sequence[T] =>
    reversed2[T](nil, sequence);

def reversed2 fun[T] => (alreadyReversed: Sequence[T], toReverse: Sequence[T]) =>
    if isNil(toReverse) then
        alreadyReversed
    else
        reversed2[T](cons[T](toReverse.head(), alreadyReversed), toReverse.tail())
