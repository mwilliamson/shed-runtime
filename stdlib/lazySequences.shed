module lazySequences;

members {
    map,
    filter,
    concat
}

import sequences;

def map fun[F, T] => (func: Function[F, T], sequence: Sequence[F]) =>
    if sequences.isNil(sequence) then
        sequences.nil
    else
        // TODO: use caching to defer evaluating the head until
        // it's required, but ensure it's only evaluated once
        MappedCons(func, func(sequence.head()), sequence.tail())

def MappedCons class[F, T] => (func: Function[F, T], head: T, tail: Sequence[F]) => {
    members {
        head fun() => head,
        tail fun() => map[F, T](func, tail)
    }
}

def filter fun[T] => (predicate: Function[T, Boolean], sequence: Sequence[T]) =>
    if sequences.isNil(sequence) then
        sequences.nil
    else if predicate(sequence.head()) then
        FilteredCons(predicate, sequence)
    else
        filter[T](predicate, sequence.tail())
        
def FilteredCons class[T] => (predicate: Function[T, Boolean], sequence: Cons[T]) => {
    members {
        head fun() => sequence.head(),
        tail fun() => filter[T](predicate, sequence.tail())
    }
}

def concat fun[T] => (sequenceOfSequences: Sequence[Sequence[T]]) =>
    if sequences.isNil(sequenceOfSequences) then
        sequences.nil
    else do {
        val headSequence = sequenceOfSequences.head();
        return if sequences.isNil(headSequence) then
            concat[T](sequenceOfSequences.tail())
        else
            ConcatSequence(headSequence, sequenceOfSequences);
    }

def ConcatSequence class[T] => (headSequence: Cons[T], sequenceOfSequences: Sequence[T]) => {
    members {
        head fun() => headSequence.head(),
        tail fun() => concat[T](sequence.cons(
            headSequence.tail(),
            sequenceOfSequences.tail()
        ))
    }
}
